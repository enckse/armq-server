//go:generate go run setup.go
package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"text/template"
)

const (
	generated = `// Code generated by setup.go. DO NOT EDIT.
package internal
`
	convHeader = `
import (
	"encoding/json"
)

const quoteByte = byte('"')
`
	strType  = "string"
	convBody = `
func JSON{{.Name}}Converter(expect {{.Name}}, d []byte, op OpType) bool {
	i, ok := JSON{{.Name}}(d)
	if ok {
		switch op {
{{if .IsNum}}
		case LessThan:
			return i < expect
		case LessTE:
			return i <= expect
		case GreatThan:
			return i > expect
		case GreatTE:
			return i >= expect
{{end}}
		case NEquals:
			return i != expect
		case Equals:
			return i == expect
		}
	}
	return false
}

func JSON{{.Name}}(d []byte) ({{.Name}}, bool) {
	var i {{.Name}}
	if err := json.Unmarshal(d, &i); err != nil {
		length := len(d)
		if length > 1 && d[0] == quoteByte && d[length-1] == quoteByte {
			return JSON{{.Name}}(d[1 : length-1])
		}
		return {{.Value}}, false
	}
	return i, true
}
`
)

// Object to generate a converter
type Object struct {
	// Type name
	Name string
	// Use type value
	Value string
	// Is a number
	IsNum bool
}

type genCall func(int, string, *bytes.Buffer)

func genType(idx int, t string, b *bytes.Buffer) {
	if idx == 0 {
		b.WriteString(convHeader)
	}
	def := "0"
	isNumeric := true
	if t == strType {
		def = "\"\""
		isNumeric = false
	}
	obj := &Object{Name: t, Value: def, IsNum: isNumeric}
	runTemplate(convBody, b, obj)
}

func converters() {
	var b *bytes.Buffer
	for i, t := range []string{"int", "int64", strType, "float64"} {
		b = genFile(i, t, b, genType)
	}
	write(b)
}

func fail(message string, err error) {
	panic(fmt.Sprintf("%s -> %v", message, err))
}

func runTemplate(text string, b *bytes.Buffer, obj *Object) {
	tmpl, err := template.New("tmpl").Parse(text)
	if err != nil {
		fail("template parse", err)
	}
	if err := tmpl.Execute(b, obj); err != nil {
		fail("template execute", err)
	}
}

func write(b *bytes.Buffer) {
	if err := ioutil.WriteFile("../internal/generated.go", b.Bytes(), 0644); err != nil {
		fail("output file", err)
	}
}

func genFile(idx int, obj string, b *bytes.Buffer, callback genCall) *bytes.Buffer {
	str := ""
	if b == nil {
		b = bytes.NewBufferString(str)
		b.WriteString(generated)
	}
	callback(idx, obj, b)
	return b
}

func gen() {
	converters()
}

func main() {
	gen()
}
