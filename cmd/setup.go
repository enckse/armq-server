//go:generate go run setup.go
package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
)

const (
	header = `// Code generated by setup.go. DO NOT EDIT.
package main

import "encoding/json"

const quoteByte = byte('"')
`
	strType = "string"
	isZero  = "0"
	body    = `
func %sConverter(expect %s, d []byte, op opType) bool {
	i, ok := %sFromJSON(d)
	if ok {
		switch op {%s
		case nEquals:
			return i != expect
		case equals:
			return i == expect
		}
	}
	return false
}

func %sFromJSON(d []byte) (%s, bool) {
	var i %s
	err := json.Unmarshal(d, &i)
	if err != nil {
		length := len(d)
		if length > 1 && d[0] == quoteByte && d[length-1] == quoteByte {
			return %sFromJSON(d[1 : length-1])
		}
		return %s, false
	}
	return i, true
}
`

	numericBody = `
		case lessThan:
			return i < expect
		case lessTE:
			return i <= expect
		case greatThan:
			return i > expect
		case greatTE:
			return i >= expect`
)

func genType(t, def string, b *bytes.Buffer) {
	caseBody := ""
	if def == isZero {
		caseBody = numericBody
	}
	genBody := fmt.Sprintf(body, t, t, t, caseBody, t, t, t, t, def)
	b.WriteString(genBody)
}

func gen() {
	str := ""
	b := bytes.NewBufferString(str)
	b.WriteString(header)
	types := []string{"int", "int64", strType, "float64"}
	for _, t := range types {
		def := isZero
		if t == strType {
			def = "\"\""
		}
		genType(t, def, b)
	}
	if err := ioutil.WriteFile("generated.go", b.Bytes(), 0644); err != nil {
		panic(err)
	}
}

func main() {
	gen()
}
